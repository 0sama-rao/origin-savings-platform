‚úÖ Complex Conditions & Logic Used

    Conditional Disable Button:
        Disabled Confirm button if input is empty or during loading.

disabled={loading || amount === 0}

Handling Edge Case for Date Difference:

    Made sure the number of months is at least 1 to avoid division by zero:

let months = goalDate.diff(currentDate, 'month') + 1;
months = months < 1 ? 1 : months;

Input Length Validation (max 15 digits):

    Prevented user from typing beyond a limit:

    if (raw.length > 15) return;

    Reusable Utility Functions (Best Practice):
        You created a helper function to validate large numbers, promoting code reusability.

üé® Tailwind CSS Properties You Used
Utility	Purpose
text-base, text-lg, text-sm, text-xl	Font sizes
text-gray-500, text-blue-600, text-[#1E2A32]	Text color customizations
font-semibold, font-normal	Font weight
w-[232px], w-full, w-[560px]	Width control
h-[56px], h-[158px], h-[64px]	Height control
mt-6, mb-4, px-4, pt-6, pb-4	Margin and padding utilities
rounded-md, rounded-lg, rounded-full	Border-radius
bg-white, bg-[#F4F8FA]	Background colors
border, border-[#E9EEF2]	Border styling
flex, justify-center, items-center, gap-4	Flexbox layout
shadow-lg	Box shadow
disabled:opacity-70, disabled:cursor-not-allowed	Disabled state styles
text-center, max-w-[560px]	Text alignment and width limits
üì± Tailwind for Responsive Mobile Styling

    You used media queries via Tailwind responsive prefixes (like md:, lg:) inside utility classes to adjust layouts.
    Why: To ensure layout fits both desktop and small screen devices (like iPhones).
    How (Example):

    className="flex flex-col md:flex-row w-full"

        This makes layout vertical on small screens and horizontal on medium+ screens.

‚ùì Potential Interview Questions You Might Get

    Why did you use useState + setTimeout on the Confirm button?
        To simulate async behavior and update UI only after confirmation.

    How did you make your layout mobile responsive?
        By using Tailwind responsive utilities and changing widths, flex direction, and margins conditionally.

    Why limit number input to 15 digits?
        JavaScript‚Äôs Number type has precision limits. Large integers can lose accuracy beyond 15-17 digits.

    Why goalDate.diff(currentDate, 'month') + 1 instead of plain difference?
        To include the current month in planning.

    Why separate helper logic into a utility function?
        To keep components clean, testable, and make code reusable.

    Why use toLocaleString() in display?
        To format large numbers with commas automatically.

    Why disable the button instead of using error messages?
        It‚Äôs cleaner UX to prevent invalid actions rather than warn afterward.




‚úÖ What to Use for Frontend Testing

Since you‚Äôve used Jest before (great), and this is a React app, you should use:
1. Jest ‚Äì the test runner + assertions

You‚Äôve already used this for backend, and it‚Äôs also used for frontend ‚Äî no change needed here.
2. React Testing Library (RTL) ‚Äì for DOM interaction

This is where the magic happens for frontend. It helps you:

    Render React components in test files
    Simulate user actions (like typing or clicking)
    Assert what users actually see

‚úÖ RTL + Jest is the best stack for testing a React + Vite app like yours.